<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flashcards</title>
  <style>
    body { font-family: sans-serif; text-align: center; background: #f8f8f8; padding: 20px;}
    h2 { margin-bottom: 6px; }
    .card { 
      background: white center/cover no-repeat;
      border-radius: 14px;
      box-shadow: 0 2px 16px rgba(0,0,0,0.10);
      padding: 50px 20px;
      margin: 25px auto 10px;
      width: 350px;
      font-size: 28px;
      cursor: pointer;
      position: relative;
    }
    .message-overlay { position: absolute; top: -36px; left: 0; right: 0; margin: auto; background: #fff3cd; color: #856404; padding: 8px 20px; border-radius: 12px; font-size: 17px; box-shadow: 0 2px 8px rgba(0,0,0,0.12); display: none;}
    .buttons button { margin: 8px 6px; padding: 12px 22px; font-size: 17px; border-radius: 6px; border:1px solid #bbb; background:#fff; cursor:pointer; min-width:110px; min-height:50px;}
    .counter { margin-top: 8px; font-size: 20px; color:#666;}
    #voiceHint { margin-top: 8px; font-size: 16px; color: #777;}
    #resultBox { margin-top: 36px; font-size: 19px;}
    .randbox { margin-bottom: 10px; font-size: 16px;}
    input[type=checkbox]{width:18px;height:18px;vertical-align:-3px;}
    .speak-btn {
      border: none;
      background: none;
      cursor: pointer;
      position: absolute;
      right: 16px; top: 16px;
      font-size: 28px;
      color: #87a6d5;
    }
    .speak-btn:hover { color: #284574; }
    #resultImageBox {
      margin-top: 15px;
      display: flex;
      justify-content: center; /* ê°€ë¡œ ì¤‘ì•™ ì •ë ¬ */
      align-items: center;     /* ì„¸ë¡œ ì •ë ¬ (ë†’ì´ê°€ ìˆì„ ê²½ìš°) */
    }
    
    #resultImage {
      max-width: 200px;
      display: none;
    }
  </style>
</head>
<body>
  <h2>ğŸ§  <b>Flashcard í•™ìŠµ</b></h2>
  <div class="randbox">
    <label><input type="checkbox" id="randomModeChk"> ë¬´ì‘ìœ„(ëœë¤) ì¶œì œ</label>
    &nbsp;&nbsp;
    <label><input type="checkbox" id="engFirstChk" checked> ì™¸êµ­ì–´ ì²´í¬</label>
  </div>
  <div class="counter" id="counter"></div>
  <div class="card" id="card" onclick="flipCard()">
    <button class="speak-btn" onclick="event.stopPropagation(); speakCurrentCard();">ğŸ”Š</button>
    <span id="cardText">Loading...</span>
    <div class="message-overlay" id="inlineMessage"></div>
  </div>
  <div id="voiceHint"></div>
  <div class="buttons">
    <button id="prevBtn" onclick="prevCard()">â—€ ì´ì „</button>
    <button onclick="nextCard()">ë‹¤ìŒ â–¶</button>
    <button onclick="markWrong()">í‹€ë ¸ìŒ</button>
    <button onclick="speakAndStartRecognition()" id="speechBtn">ğŸ¤ ì •ë‹µ ë§í•˜ê¸°</button>
  </div>
  <div id="resultImageBox">
    <img id="resultImage" src="" alt="">
  </div>
  <div id="selfCheckBtns" style="display: none;">
    <p>ë§ì•˜ë‚˜ìš”?</p>
    <button onclick="markCorrectSelf()">â­• ë§ì•˜ìŒ</button>
    <button onclick="markWrong()">âŒ í‹€ë ¸ìŒ</button>
  </div>
  <div id="resultBox"></div>

<script>
let recognizing = false, useSpeech = false, alreadySpoken = false, showingFront = true;
const SHEET_URL = "https://docs.google.com/spreadsheets/d/1EPGeJNpj9r8wq9Q-7OocVR8T_umBBcXi2qk9P-uUXXY/export?format=csv";
let originalCards = [], cards = [], wrongCards = [], answerStatus = [];
let current = 0;

function isForeignFirst() { return document.getElementById("engFirstChk").checked; }

async function loadCards() {
  const response = await fetch(SHEET_URL);
  const text = await response.text();
  const rows = text.trim().split("\n").slice(1);
  originalCards = rows.map(row => {
    const [front, back] = row.split(",");
    return { front: front.trim(), back: back.trim() };
  });
  resetToFullDeck();
}

function resetToFullDeck() {
  cards = [...originalCards];
  if (document.getElementById("randomModeChk").checked) shuffle(cards);
  wrongCards = [];
  answerStatus = new Array(cards.length).fill(null);
  current = 0;
  updateCard();
  document.getElementById("resultBox").innerHTML = "";
}

function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

function speak(text, lang, callback) {
  if (!window.speechSynthesis) { if (callback) callback(); return; }
  window.speechSynthesis.cancel();
  setTimeout(() => {
    const utter = new SpeechSynthesisUtterance(text);
    utter.lang = lang;
    if (callback) utter.onend = callback;
    window.speechSynthesis.speak(utter);
  }, 150);
}

function speakAndStartRecognition() {
  if (!alreadySpoken) {
    alreadySpoken = true;
    let content = isForeignFirst() ? cards[current].front : getFirstAnswer(cards[current].back);
    let lang = isForeignFirst() ? "en-US" : "ko-KR";
    speak(content, lang, startSpeechRecognition);
  } else {
    startSpeechRecognition();
  }
}

function startSpeechRecognition() {
  if (!('webkitSpeechRecognition' in window)) return;
  const recognition = new webkitSpeechRecognition();
  recognition.lang = isForeignFirst() ? "ko-KR" : "en-US";
  recognition.start();
  recognizing = true;
  recognition.onresult = function(event) {
    let said = event.results[0][0].transcript.trim();
    let answer = isForeignFirst() ? getFirstAnswer(cards[current].back) : cards[current].front;
    if (said === answer) {
      markCorrectSelf();
      showInlineMessage("ì •ë‹µ!");
    } else {
      markWrong();
      showInlineMessage("ì˜¤ë‹µ!");
    }
  };
  recognition.onend = () => recognizing = false;
}

function speakCurrentCard() {
  let text, lang;
  if (showingFront) {
    text = isForeignFirst() ? cards[current].front : getFirstAnswer(cards[current].back);
    lang = isForeignFirst() ? "en-US" : "ko-KR";
  } else {
    text = isForeignFirst() ? getFirstAnswer(cards[current].back) : cards[current].front;
    lang = isForeignFirst() ? "ko-KR" : "en-US";
  }
  speak(text, lang);
}

function showResultImage(isCorrect) {
  const img = document.getElementById("resultImage");
  if (isCorrect === true) img.src = "correct.jpg";
  else if (isCorrect === false) img.src = "wrong.jpg";
  else { img.style.display = "none"; return; }
  img.style.display = "block";
}

function updateCard() {
  showingFront = true;
  showResultImage(null);
  let content = isForeignFirst() ? cards[current].front : getFirstAnswer(cards[current].back);
  document.getElementById("cardText").textContent = content;
  const correctSoFar = answerStatus.filter(s => s === "correct").length;
  const wrongSoFar = answerStatus.filter(s => s === "wrong").length;
  document.getElementById("counter").innerHTML =
    `ë¬¸ì œ ${current + 1} / ${cards.length} | ë§ì¶˜ ê°œìˆ˜: ${correctSoFar} | í‹€ë¦° ê°œìˆ˜: ${wrongSoFar}`;
  speak(content, isForeignFirst() ? "en-US" : "ko-KR");
  document.getElementById("selfCheckBtns").style.display = 'none';
  document.getElementById("prevBtn").style.display = current === 0 ? "none" : "inline-block";
}

function flipCard() {
  let content, lang;
  if (showingFront) {
    content = isForeignFirst() ? getFirstAnswer(cards[current].back) : cards[current].front;
    lang = isForeignFirst() ? "ko-KR" : "en-US";
  } else {
    content = isForeignFirst() ? cards[current].front : getFirstAnswer(cards[current].back);
    lang = isForeignFirst() ? "en-US" : "ko-KR";
  }
  document.getElementById("cardText").textContent = content;
  speak(content, lang);
  showingFront = !showingFront;
  if (!useSpeech && !showingFront) document.getElementById("selfCheckBtns").style.display = 'block';
}

function markWrong() {
  if (answerStatus[current] !== "wrong") {
    answerStatus[current] = "wrong";
  }
  wrongCards.push(cards[current]);
  showResultImage(false);
  showAnswerThenNextCard();
}

function markCorrectSelf() {
  answerStatus[current] = "correct";
  showResultImage(true);
  showAnswerThenNextCard();
}

function nextCard() {
  if (answerStatus[current] !== "correct") {
    answerStatus[current] = "correct";
  }
  current++;
  if (current < cards.length) {
    updateCard();
  } else {
    const correct = answerStatus.filter(s => s === "correct").length;
    const wrong = answerStatus.filter(s => s === "wrong").length;
    document.getElementById("resultBox").innerHTML =
      `âœ… ${correct}ê°œ ë§ê³  âŒ ${wrong}ê°œ í‹€ë ¸ì–´ìš”!<br><br>
       <button onclick="retryWrong()">í‹€ë¦° ê²ƒë§Œ ë‹¤ì‹œí•˜ê¸°</button>
       <button onclick="resetToFullDeck()">ì „ì²´ ë‹¤ì‹œí•˜ê¸°</button>`;
  }
}

function prevCard() {
  // ì´ì „ ë¬¸ì œë¡œ ëŒì•„ê°€ë©´ ê¸°ë¡ ì·¨ì†Œ
  if (answerStatus[current] === "correct" || answerStatus[current] === "wrong") {
    answerStatus[current] = null;
  }
  current = Math.max(0, current - 1);
  updateCard();
}

function retryWrong() {
  if (wrongCards.length > 0) {
    cards = [...wrongCards];
    wrongCards = [];
    answerStatus = new Array(cards.length).fill(null);
    current = 0;
    updateCard();
    document.getElementById("resultBox").innerHTML = "";
  }
}

function showInlineMessage(msg) {
  const box = document.getElementById("inlineMessage");
  box.textContent = msg;
  box.style.display = 'block';
  if (box.timer) clearTimeout(box.timer);
  box.timer = setTimeout(() => box.style.display = 'none', 1500);
}

function showAnswerThenNextCard() {
  let answerText = isForeignFirst() ? getFirstAnswer(cards[current].back) : cards[current].front;
  document.getElementById("cardText").textContent = answerText;
  speak(answerText, isForeignFirst() ? "ko-KR" : "en-US");
  showingFront = false;
  setTimeout(nextCard, 1000);
}

function getFirstAnswer(ansStr) {
  return ansStr.split(/,|ï¼Œ/)[0].trim();
}

if ('webkitSpeechRecognition' in window) {
  useSpeech = true;
  document.getElementById("speechBtn").style.display = "inline-block";
} else {
  useSpeech = false;
  document.getElementById("speechBtn").style.display = "none";
}

document.addEventListener('DOMContentLoaded', () => {
  document.getElementById('randomModeChk').addEventListener('change', resetToFullDeck);
  document.getElementById('engFirstChk').addEventListener('change', resetToFullDeck);
});

loadCards();
</script>
</body>
</html>
